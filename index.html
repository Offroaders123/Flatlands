<!DOCTYPE html>
<html lang="en-US">

<head>

<title>Flatlands</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="author" content="Brandon Bennett">
<meta name="description" content="Flatlands is a cross platform 2D game built in the browser!">
<meta property="og:title" content="Flatlands">
<meta property="og:description" content="Flatlands is a cross platform 2D game built in the browser!">
<meta property="og:image" content="https://offroaders123.github.io/Flatlands/resources/share-temp.png">
<meta property="og:url" content="https://offroaders123.github.io/Flatlands/">
<meta name="twitter:card" content="summary_large_image">
<meta name="theme-color" content="#779c43">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Flatlands">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<base href="." target="_blank">
<link rel="canonical" href="https://offroaders123.github.io/Flatlands/">
<link rel="manifest" href="manifest.webmanifest">
<link rel="alternate icon" type="image/png" sizes="16x16" href="resources/icon-16.png">
<link rel="alternate icon" type="image/png" sizes="32x32" href="resources/icon-32.png">
<link rel="apple-touch-icon" sizes="180x180" href="resources/app-apple-touch-180.png">

<script>
  window.Flatlands = {
    version: 0.43,
    environment: () => ({
      touch_device: ("ontouchstart" in window)
    })
  };
  if (Flatlands.environment().touch_device) document.documentElement.classList.add("touch-device");
</script>

<style>
  *, *::before, *::after {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  :root {
    --safe-area-inset-left: env(safe-area-inset-left,0px);
    --safe-area-inset-right: env(safe-area-inset-right,0px);
    --safe-area-inset-top: env(safe-area-inset-top,0px);
    --safe-area-inset-bottom: env(safe-area-inset-bottom,0px);
  }
  html {
    width: 100%;
    height: calc(100% + var(--safe-area-inset-top));
    overflow: hidden;
  }
  body {
    position: fixed;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", system-ui, sans-serif;
    image-rendering: pixelated;
    overflow: auto;
    -webkit-user-select: none;
    user-select: none;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }
  button {
    color: inherit;
    font: inherit;
    border-radius: 0;
  }
  #canvas {
    margin: auto;
    width: 100%;
    height: 100%;
    z-index: 1;
  }
  #hud {//background: gray;
    --padding: 12px;//border: solid red;
    padding: max(var(--padding),var(--safe-area-inset-top)) max(var(--padding),var(--safe-area-inset-right)) max(var(--padding),var(--safe-area-inset-bottom)) max(var(--padding),var(--safe-area-inset-left));
    position: absolute;
    inset: 0;
    display: grid;
    grid-template-areas:
      "version ."
      "coordinates ."
      "dpad hotbar";
    grid-template-columns: min-content 1fr;
    grid-template-rows: repeat(2,min-content) 1fr;
    gap: 8px;
    justify-items: start;
    align-items: end;
    color: #ffffff;
    font-size: 20px;
    font-family: ui-monospace, "Noto Sans Mono", "Cousine", monospace;
    line-height: 1;
    text-shadow: 0.175ch 0.175ch 0 #000000;
    white-space: pre;
  }
  #hud > * {
    z-index: 1;
  }
  #version {
    grid-area: version;
  }
  #coordinates {
    grid-area: coordinates;
  }
  #hotbar {
    grid-area: hotbar;
    grid-column: 1 / -1;
    justify-self: center;
    display: flex;
    list-style: none;
    /*--hotbar-scale: min(min(12vh,8vw),64px);*/
    /* Note for later: https://stackoverflow.com/questions/52467896/transform-scale-using-viewport-units */
  }
  #hotbar .slot {
    padding: 12px;
    position: relative;
    display: flex;
    background: url("textures/interfaces/slot.png") no-repeat 50%;
    background-size: calc(100% - 8px);
  }
  #hotbar .slot.active::before {
    content: "";
    position: absolute;
    inset: 0;
    background: url("textures/interfaces/slot_active.png") no-repeat;
    background-size: cover;
  }
  #hotbar .item {
    width: 64px;
    height: 64px;
    background: var(--item-sprite) no-repeat;
    background-size: cover;
  }
  #dpad {
    //margin: 4px;
    grid-area: dpad;
    display: grid;
    grid-template-areas:
      ". up ."
      "left . right"
      ". down .";
    color: initial;
    white-space: initial;
    z-index: initial;
  }
  :root:not(.touch-device) #dpad {
    //display: none;
  }
  #dpad button {
    width: 56px;
    height: 56px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #cccccc;
    border: 2px solid #000000cc;
    border-radius: 12px;
    z-index: 1;
    transition: opacity 250ms;
  }
  #dpad button::before {
    content: "";
    border: 10px solid transparent;
  }
  #dpad button.active {
    opacity: 0.6;
  }
  #dpad [data-left] {
    margin-right: -2px;
    grid-area: left;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
  }
  #dpad [data-left]::before {
    border-left: none;
    border-right-color: currentColor;
  }
  #dpad [data-right] {
    margin-left: -2px;
    grid-area: right;
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }
  #dpad [data-right]::before {
    border-left-color: currentColor;
    border-right: none;
  }
  #dpad [data-up] {
    margin-bottom: -2px;
    grid-area: up;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }
  #dpad [data-up]::before {
    border-top: none;
    border-bottom-color: currentColor;
  }
  #dpad [data-down] {
    margin-top: -2px;
    grid-area: down;
    border-top-left-radius: 0;
    border-top-right-radius: 0;
  }
  #dpad [data-down]::before {
    border-top-color: currentColor;
    border-bottom: none;
  }
  .hatchet {
    --item-sprite:hatchet;
  }
  .pickmatic {
    --item-sprite:pickmatic;
  }
  .pizza {
    --item-sprite:pizza;
  }
  .spade {
    --item-sprite:spade;
  }
  .spearsword {
    --item-sprite:spearsword;
  }
</style>

</head>

<body ontouchstart>

<canvas id="canvas"></canvas>

<div id="hud">

<span id="version"></span>
<span id="coordinates"></span>

<ul id="hotbar">
  <li class="slot" data-slot="1">
    <span class="item spearsword"></span>
  </li>
  <li class="slot" data-slot="2">
    <span class="item pickmatic"></span>
  </li>
  <li class="slot active" data-slot="3">
    <span class="item hatchet"></span>
  </li>
  <li class="slot" data-slot="4">
    <span class="item spade"></span>
  </li>
  <li class="slot" data-slot="5">
    <span class="item"></span>
  </li>
  <li class="slot" data-slot="6">
    <span class="item pizza"></span>
  </li>
</ul>

<div id="dpad">
  <button data-left tabindex="-1"></button>
  <button data-right tabindex="-1"></button>
  <button data-up tabindex="-1"></button>
  <button data-down tabindex="-1"></button>
</div>

</div>

<script>
// Service Worker
window.addEventListener("load",() => navigator.serviceWorker.register("service-worker.js"));

// Version
const version = document.querySelector("#version");
version.textContent = `Flatlands v${Flatlands.version}`;

// Canvas
const canvas = document.querySelector("#canvas");
const ctx = canvas.getContext("2d",{ alpha: false });

let scaling = 4;

const offsetX = () => Math.round(canvas.width / 2);
const offsetY = () => Math.round(canvas.height / 2);

new ResizeObserver(() => {
  const { offsetWidth: width, offsetHeight: height } = canvas;
  canvas.width = width / scaling;
  canvas.height = height / scaling;
  ctx.imageSmoothingEnabled = false;
  animate({ recursive: false });
}).observe(canvas);

let tick = 0;

// Input
const key = {
  left: false,
  right: false,
  up: false,
  down: false
};
const gamepads = [];

window.addEventListener("gamepadconnected",event => {
  if (!event.gamepad.mapping) return;
  gamepads.push(event.gamepad.index);
  //console.log("Connected!\n",navigator.getGamepads()[event.gamepad.index]);
});
window.addEventListener("gamepaddisconnected",event => {
  if (!event.gamepad.mapping) return;
  //console.log("Disconnected.\n",event.gamepad.index);
  gamepads.splice(gamepads.indexOf(event.gamepad.index));
});

document.addEventListener("keydown",event => {
  if (event.repeat || document.activeElement != document.body) return;
  document.documentElement.classList.remove("touch-device");
  if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey) return;
  if (["Digit1","Digit2","Digit3","Digit4","Digit5","Digit6"].includes(event.code)){
    event.preventDefault();
    setSlot(event.code.replace(/Digit/,""));
  }
  if (["ArrowLeft","KeyA"].includes(event.code)){
    event.preventDefault();
    key.left = event.code;
  }
  if (["ArrowRight","KeyD"].includes(event.code)){
    event.preventDefault();
    key.right = event.code;
  }
  if (["ArrowUp","KeyW"].includes(event.code)){
    event.preventDefault();
    key.up = event.code;
  }
  if (["ArrowDown","KeyS"].includes(event.code)){
    event.preventDefault();
    key.down = event.code;
  }
});
document.addEventListener("keyup",event => {
  if (document.activeElement != document.body) return;
  if (["ArrowLeft","KeyA"].includes(event.code)) key.left = false;
  if (["ArrowRight","KeyD"].includes(event.code)) key.right = false;
  if (["ArrowUp","KeyW"].includes(event.code)) key.up = false;
  if (["ArrowDown","KeyS"].includes(event.code)) key.down = false;
});
document.addEventListener("touchstart",() => document.documentElement.classList.add("touch-device"));
document.addEventListener("contextmenu",event => event.preventDefault());

hotbar.addEventListener("touchstart",event => {
  event.preventDefault();
  if (event.target.closest(".slot")) setSlot(event.target.closest(".slot").getAttribute("data-slot"));
});

dpad.down = event => {
  event.preventDefault();
  if (event.target.matches("button")) event.target.classList.add("active");
  if (event.target.matches("[data-left]")) key.left = "DPadLeft";
  if (event.target.matches("[data-right]")) key.right = "DPadRight";
  if (event.target.matches("[data-up]")) key.up = "DPadUp";
  if (event.target.matches("[data-down]")) key.down = "DPadDown";
};
dpad.up = event => {
  if (event.target.matches("button")) event.target.classList.remove("active");
  if (event.target.matches("[data-left]")) key.left = false;
  if (event.target.matches("[data-right]")) key.right = false;
  if (event.target.matches("[data-up]")) key.up = false;
  if (event.target.matches("[data-down]")) key.down = false;
};
dpad.addEventListener("touchstart",event => dpad.down(event));
dpad.addEventListener("touchend",event => dpad.up(event));
dpad.addEventListener("pointerdown",event => dpad.down(event));
dpad.addEventListener("pointerup",event => dpad.up(event));

function setSlot(index){
  const active = hotbar.querySelector(`.slot[data-slot="${index}"]`);
  hotbar.querySelectorAll(".slot.active").forEach(slot => slot.classList.remove("active"));
  active.classList.add("active");
  const slot = active.querySelector(".item");
  player.held_item = window.getComputedStyle(slot).getPropertyValue("--item-sprite") || null;//console.log(`Player held item: ${player.held_item}`);
}

// Game Properties
const missingTextureSprite = new Image();
missingTextureSprite.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACAQMAAABIeJ9nAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAZQTFRF+QD/AAAASf/37wAAAAxJREFUeJxjcGBoAAABRADBOnocVgAAAABJRU5ErkJggg==";
let entities, items, terrain, grassPattern;

(async () => {

let entitiesFile = await fetch("feature_definitions/entities.json");
entities = await entitiesFile.json();
let itemsFile = await fetch("feature_definitions/items.json");
items = await itemsFile.json();
let terrainFile = await fetch("feature_definitions/terrain.json");
terrain = await terrainFile.json();

for (entity in entities) await loadSprite(entity,entities);
for (item in items) await loadSprite(item,items);
for (terraine in terrain) await loadSprite(terraine,terrain);
grassPattern = ctx.createPattern(terrain["ground"].texture.image,"repeat");

async function loadSprite(key,object){
  return new Promise((resolve,reject) => {
    let sprite = new Image(), { source } = object[key].texture;
    sprite.addEventListener("load",event => {//console.log(`${new URL(sprite.src).pathname.split("/").pop()} %cload?`,"color: green; font-size: 125%; font-weight: bold;");
      object[key].texture.image = sprite;
      if (object === items){/* This and the error listener should be made into a single function, they both add the sprites to the items in the hotbar */
        let slots = hotbar.querySelectorAll(`.slot .item.${key}`);
        if (slots.length !== 0){
          slots.forEach(slot => {
            slot.style.setProperty("background-image",`url("${source}")`);
          });
        }
      }
      resolve();
    });
    sprite.addEventListener("error",event => {//console.log(`${new URL(sprite.src).pathname.split("/").pop()} %cERROR!`,"color: red; font-size: 125%; font-weight: bold;");
      if (object === items){/* Function mentioned above */
        let slots = hotbar.querySelectorAll(`.slot .item.${key}`);
        if (slots.length !== 0){
          slots.forEach(slot => {
            slot.style.setProperty("background-image",`url("${missingTextureSprite.src}")`);
          });
        }
      }
      resolve();
    });
    sprite.src = source;
  });
}

})();

// Environment
const explored = {
  left: 0,
  right: canvas.width,
  top: 0,
  bottom: canvas.height
};

// Player
class Player {
  constructor(){
    this.x = 0;
    this.y = 0;
    this.width = 16;
    this.height = 32;
    this.speed = 2;
    this.tick = 0;
    this.ticks = 24;
    this.frame = 0;
    this.frames = 2;
    this.column = 0;
    this.columns = 4;
    this.directionX = "right";
    this.directionY = false;
    this.held_item = "hatchet";
  }
  update(){
    const gamepad = navigator.getGamepads()[gamepads[0]];
    let [axisX,axisY] = (gamepad) ? gamepad.axes : [null,null,null,null], [left1,right1] = (gamepad) ? [gamepad.buttons[4].value,gamepad.buttons[5].value] : [null,null];
    if (gamepad){
      key.left = (Math.round(axisX * 1000) < 0);
      key.right = (Math.round(axisX * 1000) > 0);
      key.up = (Math.round(axisY * 1000) < 0);
      key.down = (Math.round(axisY * 1000) > 0);
      let active = parseInt(hotbar.querySelector(".slot.active").getAttribute("data-slot"));
      if (left1 && !right1 && tick % 10 == 0) setSlot((active - 1 > 0) ? active - 1 : 6);
      if (right1 && !left1 && tick % 10 == 0) setSlot((active + 1 < 7) ? active + 1 : 1);
    }
    if (key.left && !key.right) this.x += this.speed * (-axisX || 1);
    if (key.right && !key.left) this.x -= this.speed * (axisX || 1);
    if (key.up && !key.down) this.y += this.speed * (-axisY || 1);
    if (key.down && !key.up) this.y -= this.speed * (axisY || 1);

    if (key.left && !key.right) this.directionX = "left";
    if (key.right && !key.left) this.directionX = "right";

    if (key.down && !key.up && !key.left && !key.right) this.directionY = "down";
    if (key.up && !key.down && !key.left && !key.right) this.directionY = "up";
    if (!key.up && !key.down || key.left || key.right) this.directionY = false;

    if (this.directionY == "down") this.column = 2;
    if (this.directionY == "up") this.column = 3;
    if (!this.directionY) this.column = 1;

    if ((key.left && !key.right) || (key.right && !key.left) || (key.up && !key.down) || (key.down && !key.up)){
      this.tick++;
    } else {
      this.column = 0;
      this.directionY = false;
    }
    if (this.tick > this.ticks - 1){
      this.tick = 0;
      (this.frame < this.frames - 1) ? this.frame++ : this.frame = 0;
    }
  }
  draw(){
    let heldItemImage = (player.held_item !== null) ? (items && items[player.held_item].texture.image) ? items[player.held_item].texture.image : undefined : null;
    let scale = 1, offset = 1, itemScale = 1;

    if (this.directionX == "left" && this.directionY != "up"){
      scale = -1;
    }
    if (this.directionX == "right" && this.directionY == "up"){
      scale = -1;
    }
    if (this.directionX == "right" && this.directionY){
      offset = 0;
    }
    if (this.directionY){
      itemScale = 2/3;
    }

    ctx.setTransform(scale,0,0,1,offsetX(),offsetY());
    ctx.transform(1,0,0,1,-7,14);
    if (entities && entities["shadow"].texture.image) ctx.drawImage(entities["shadow"].texture.image,0,0,this.width - 2,4);
    if (this.directionY == "down"){
      this.drawCharacter(scale,offset);
      this.drawItem(heldItemImage,scale,itemScale);
    } else {
      this.drawItem(heldItemImage,scale,itemScale);
      this.drawCharacter(scale,offset);
    }

    ctx.setTransform(1,0,0,1,0,0);
  }
  drawItem(itemSprite,scale,itemScale){
    if (itemSprite === null) return;
    if (!itemSprite) itemSprite = missingTextureSprite;
    const cachedSprite = (itemSprite !== missingTextureSprite);
    ctx.setTransform(scale,0,0,1,offsetX(),offsetY());
    ctx.transform(1,0,0,1,this.width / -2 + 1,this.height / -2);
    ctx.transform(1,0,0,1,((cachedSprite) ? itemSprite.naturalWidth : 16) * 0.625,((cachedSprite) ? itemSprite.naturalHeight : 16) * 0.3125);
    ctx.scale(-1 * itemScale,1);
    ctx.transform(1,0,0,1,-((cachedSprite) ? itemSprite.naturalWidth : 16),((cachedSprite) ? itemSprite.naturalHeight : 16));
    ctx.rotate(Math.PI * -1 / 2);
    //ctx.fillStyle = "#00ff0030";
    //ctx.fillRect((this.directionY) ? (this.directionY == "up") ? -2 : -1 : 0,1,itemSprite.naturalWidth,itemSprite.naturalHeight);
    ctx.drawImage(itemSprite,(this.directionY) ? (this.directionY == "up") ? -2 : -1 : 0,1,(cachedSprite) ? itemSprite.naturalWidth : 16,(cachedSprite) ? itemSprite.naturalHeight : 16);
  }
  drawCharacter(scale,offset){/* Mob idea name: ooogr */
    const cachedSprite = (entities && entities["player"].texture.image);
    let charSprite = (cachedSprite) ? entities["player"].texture.image : missingTextureSprite;
    ctx.setTransform((this.directionX == "left" && !this.directionY) ? -1 : 1,0,0,1,offsetX(),offsetY());
    ctx.transform(1,0,0,1,this.width / -2 + offset,this.height / -2);
    if ( cachedSprite) ctx.drawImage(charSprite,this.width * ((this.column != 0) ? this.frame : 0),this.height * this.column,this.width,this.height,0,0,this.width,this.height);
    if (!cachedSprite) ctx.drawImage(charSprite,0,0,this.width,this.height);
  }
}
const player = new Player();

// Trees
const treesArray = [];
class Tree {
  constructor(){
    this.x = Math.floor(Math.random() * canvas.width) - Math.floor(canvas.width / 2) - player.x - 96 / 2;
    //this.y = Math.floor(Math.random() * canvas.height) - canvas.height / 2 - player.y - 192 / 2;
    if (key.up && !key.down){
      this.y = - player.y - offsetY() - 192;
      if (explored.top > this.y) explored.top = this.y;
    }
    if (key.down && !key.up){
      this.y = canvas.height - player.y - offsetY();
      if (explored.bottom < this.y) explored.bottom = this.y;
    }
    this.width = 96;
    this.height = 192;
  }
  draw(){
    ctx.drawImage((terrain && terrain["tree"].texture.image) ? terrain["tree"].texture.image : missingTextureSprite,this.x + player.x + offsetX(),this.y + player.y + offsetY(),this.width,this.height);
  }
}
function handleTrees(){
  if (tick % 20 == 0){
    if (canvas.height / -2 - player.y - offsetX() < explored.top || canvas.height - player.y - offsetY() > explored.bottom){
      if (key.up && !key.down) treesArray.unshift(new Tree());
      if (key.down && !key.up) treesArray.push(new Tree());
    }
  }
  treesArray.forEach(tree => {
    tree.draw();
  });
}

// Coordinates
const coordinates = document.querySelector("#coordinates");
function setCoordinateLabel(){
  coordinates.textContent = `(${Math.round(player.x / 16) * -1}, ${Math.round(player.y / 16)})`;
}

//for (let i = 0; i < 4; i++) treesArray.push(new Tree());

// Rendering
function animate({ recursive = true } = {}){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = (grassPattern) ? grassPattern : "#779c43";
  ctx.beginPath();
  ctx.rect(0,0,canvas.width,canvas.height);
  if (grassPattern) ctx.setTransform(1,0,0,1,offsetX() + player.x,offsetY() + player.y);
  ctx.fill();
  ctx.setTransform(1,0,0,1,0,0);
  handleTrees();
  player.update();
  player.draw();
  setCoordinateLabel();
  tick++;
  if (recursive) window.requestAnimationFrame(animate);
}
animate();
</script>

</body>

</html>